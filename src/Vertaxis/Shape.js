


Vertaxis.define('Vertaxis.Shape', null, function Shape()
{
	console.log('Shape init');
},
{

});


Vertaxis.define('Vertaxis.Box', Vertaxis.Shape, 
	function Boxy(cxt, x, y, width, height, angle)
	{
		Vertaxis.Box.superclass.apply(this,arguments);
		console.log('Box init');

		this.cxt = cxt;
		this.width = width;
		this.height = height;
		this.square = this.width * this.height;

		this.radius = Math.sqrt(this.width * this.width  + this.height * this.height) / 2;

		//this.size = size;
		this.halfW = this.width / 2;
		this.halfH = this.height / 2;

		if(angle)
		{
			this.angle = Vertaxis.Math.rad(angle);
		}
		else
		{
			this.angle = 0;
		}

		this.moveTo(x,y);

	},
	{	
		type: 'rect',
		draw: function()
		{
			this.cxt.beginPath();
			this.cxt.moveTo(
				this.vertex[3].x,
				this.vertex[3].y
			);

			for(var i = 0; i < 4; i++)
			{
				this.cxt.lineTo(
					this.vertex[i].x,
					this.vertex[i].y
				);
			}

			this.cxt.lineTo(
				this.vertex[1].x,
				this.vertex[1].y
			);

			this.cxt.moveTo(
				this.vertex[0].x,
				this.vertex[0].y
			);

			this.cxt.lineTo(
				this.vertex[2].x,
				this.vertex[2].y
			);

			var top = {
				x: (this.vertex[0].x + this.vertex[1].x) / 2,
				y: (this.vertex[0].y + this.vertex[1].y) / 2
			}

			this.cxt.moveTo(this.x,this.y);
			this.cxt.lineTo(top.x, top.y);

			this.cxt.set('strokeStyle','#fff');
			this.cxt.closePath();
			this.cxt.stroke();

		},

		moveTo: function(x,y)
		{
			this.x = x;
			this.y = y;

			this.updateVertex();
		},

		move: function(dx,dy)
		{
			this.x += dx;
			this.y += dy;

			this.updateVertex();
		},

		updateVertex: function()
		{
			this.calculateVertex();
			if (this.angle != 0 )
			{
				this.translateVertex();
			}
		},

		setAngle: function(angle)
		{
			this.angle = Vertaxis.Math.rad(angle);
			this.updateVertex();
		},

		calculateVertex: function()
		{
			var x1 = this.x - this.halfW;
			var x2 = this.x + this.halfW;
			var y1 = this.y - this.halfH;
			var y2 = this.y + this.halfH;

			this.vertex = [
				{ x: x1, y: y1},
				{ x: x2, y: y1},
				{ x: x2, y: y2},
				{ x: x1, y: y2}
			];
		},

		translateVertex: function()
		{
			var center = {x: this.x, y: this.y};
			var vl = this.vertex.length;
			for(var i = 0; i < vl; i++)
			{
				this.vertex[i] = Vertaxis.Math.rotatePoint(this.vertex[i], this.angle, center);
			}
		},

		collideWith: function(shape)
		{
			if (this.distanceToCenter(shape) > this.radius + shape.radius)
			{
				console.log('too far')
				return false;
			}

			if (shape.type == 'circle')
			{
				return this.collideWithCircle(shape);
			}

			if (shape.type == 'rect' && this.type == 'rect' &&
				shape.angle == 0 && this.angle == 0)
			{
				return this.collideOrthogonalWith(shape);
			}

			var figures = [this,shape];
			var figure_a;
			var figure_b;
			var square;
			var v;
			var vl1;
			var vl2;
			var p1, p2;
			var point;
			var triangleSquare;


			for(var n = 0; n < 2; n++)
			{
				figure_a = figures[(n == 0) ? 0 : 1];
				figure_b = figures[(n == 0) ? 1 : 0];
				
				//Shape square calculated be triangles method
				square = 0;
				v = figure_b.vertex;
				for (var i = 0; i < v.length; i++)
				{
					p1 = i;
					p2 = (i < v.length - 1) ? i + 1 : 0;

					square += 1/2 * Math.abs( 
						(v[p2].x - v[p1].x) * (figure_b.y - v[p1].y) - 
						(v[p2].y - v[p1].y) * (figure_b.x - v[p1].x)
					);
				}


				for(var m = 0; m < figure_a.vertex.length; m++)
				{
					//Count squares of 4 triangles
					// generated by point and 4 sides of shape
					point = figure_a.vertex[m];
					
					triangleSquare = 0;
					v = figure_b.vertex;
				
					for (var i = 0; i < v.length; i++)
					{
						p1 = i;
						p2 = (i < v.length - 1) ? (i + 1) : 0;

						triangleSquare += 1/2 * Math.abs(
							(v[p2].x - v[p1].x) * (point.y - v[p1].y) - 
							(v[p2].y - v[p1].y) * (point.x - v[p1].x)
						);
					}

					if (triangleSquare - square < 50) //Small gap 
					{
						this.lastCollision = shape;
						return true;
					}
				}

			}

			return false
		},

		collideOrthogonalWith: function(shape)
		{
			if (
				this.x - this.halfW < shape.x + shape.halfW &&
		        this.x + this.halfW > shape.x - shape.halfW &&
		        this.y - this.halfH < shape.y + shape.halfH &&
		        this.y + this.halfH > shape.y - shape.halfH )
	        {
	        	this.lastCollision = shape;
	        	return true;
	        }
			return false;
		},

		collideWithCircle: function(circle)
		{
			var center = {x:circle.x, y: circle.y};
			var r = circle.radius;

			//First check vertexes for belonging to circle
			var vertexesInCircle = 0;
			for (var i =0; i < this.vertex.length;i++)
			{	
				//If disatnce from cetner to point is less that radius
				//this point are belong to circle
				if( Vertaxis.Math.distance(circle, this.vertex[i]) <= r)
				{
					vertexesInCircle++;
				}
			}

			//If we have vertexes in circle that mean that shapes are intersected
			if (vertexesInCircle > 0)
			{
				this.lastCollision = circle;
				return true;
			}
			
			//Check all sidex of polygon for intersect with circle
			var s1, s2,a, b;
			for (var i = 0; i < this.vertex.length; i++)
			{
				s1 = i;
				s2 = (i < this.vertex.length - 1) ? i + 1 : 0;

				//Tranalsate points to local plane
				a = Vertaxis.Math.translatePoint(this.vertex[s1], center);
				b = Vertaxis.Math.translatePoint(this.vertex[s2], center);

				
				var dx = b.x - a.x;
				var dy = b.y - a.y;

				var dr = Math.sqrt(dx*dx + dy*dy);
				var dr2 = dx*dx + dy*dy;

				var D = (a.x * b.y) - (b.x * a.y);
				var DD = Math.pow(r, 2) * dr2 - Math.pow(D, 2) 
			
				if (DD >= 0)
				{
					//POints of circle and line intersection
					var dt = Math.sqrt( DD );

					var x = Math.round( (  D * dy - ((dy < 0) ? -1 : 1) * dx * dt ) / dr2 );
					var y = Math.round( (- D * dx - Math.abs(dy) * dt ) / dr2 );
					var p1 = Vertaxis.Math.translatePoint({x:x, y:y}, center, true);

					var x = Math.round( (  D * dy + ((dy < 0) ? -1 : 1) * dx * dt ) / dr2 );
					var y = Math.round( (- D * dx + Math.abs(dy) * dt ) / dr2 );
					var p2 = Vertaxis.Math.translatePoint({x:x,y:y}, center, true);

					var points = [p1,p2];
					// INtersection appear if point of line and circle intersection
					// lie on the segment [a,b]
					if( Vertaxis.Math.isPointOnSegment(p1,a,b) ||
						Vertaxis.Math.isPointOnSegment(p2,a,b) )
					{
						this.lastCollision = circle;
						return true;
					}
				}
			}

			//If there are nso insterseptions with all sides return false
			return false;
		},

		distanceToCenter: function(shape)
		{
			return Vertaxis.Math.distance(this,shape);
		}
	}
);


Vertaxis.define('Vertaxis.Circle', Vertaxis.Box,
	function Circle(cxt, x, y, radius, angle)
	{
		//Vertaxis.Circle.superclass.apply(this,arguments);
		console.log('Circle init');

		this.cxt = cxt;
		this.width = radius*2;
		this.height = radius*2;
		this.radius = radius;
		this.square = Math.PI * this.radius * this.radius;

		if(angle)
		{
			this.angle = Vertaxis.Math.rad(angle);
		}
		else
		{
			this.angle = 0;
		}

		this.moveTo(x,y);
	},
	{
		type: 'circle',
		draw: function()
		{
			this.cxt
				.save()
				.beginPath()
				.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false)
				.closePath()
				.set('strokeStyle','#fff')
				.stroke();

			var top = {
				x: this.x,
				y: this.y - this.radius
			};

			var topRotated = Vertaxis.Math.rotatePoint(top, this.angle, this);

			this.cxt
				.beginPath()
				.moveTo(topRotated.x, topRotated.y)
				.lineTo(this.x, this.y)
				.closePath()
				.set('strokeStyle','#fff')
				.stroke();
		},

		updateVertex: function()
		{
			//empty because circle have no vertexes
		}
	}
);



Vertaxis.define('Vertaxis.Triangle', Vertaxis.Box,
	function Triangle(cxt, x, y, size, angle)
	{
		//Vertaxis.Circle.superclass.apply(this,arguments);
		console.log('Triangle init');

		this.cxt = cxt;
		//this.radius = radius;

		this.size = size;
		
		this.radius = size / Math.sqrt(3);

		if(angle)
		{
			this.angle = Vertaxis.Math.rad(angle);
		}
		else
		{
			this.angle = 0;
		}

		this.moveTo(x,y);
	},
	{
		type: 'triangle',
		draw: function()
		{
			this.cxt.beginPath();
			this.cxt.moveTo(
				this.vertex[2].x,
				this.vertex[2].y
			);

			for(var i = 0; i < 3; i++)
			{
				this.cxt.lineTo(
					this.vertex[i].x,
					this.vertex[i].y
				);
			}

			this.cxt.set('fillStyle','#fff');
			this.cxt.closePath();
			this.cxt.stroke();
			
		},

		calculateVertex: function()
		{
			var center = {x: this.x, y: this.y};
			var v1 = {
				x: this.x,
				y: this.y - this.radius
			};
			var v2 = Vertaxis.Math.rotatePoint(v1, 2 * Math.PI / 3, this);
			var v3 = Vertaxis.Math.rotatePoint(v1, 4 * Math.PI / 3, this);
			this.vertex = [v1, v2, v3];
		}
	}
);



